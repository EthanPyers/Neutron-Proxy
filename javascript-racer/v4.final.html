<!DOCTYPE html>
<html>
<head>
  <title>Javascript Racer - Fullscreen</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="common.css" rel="stylesheet" type="text/css" />
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden; /* Prevent scrolling */
      height: 100%;
      width: 100%;
    }
    #canvas {
      display: block; /* Remove any inline spacing */
      height: 100%;
      width: 100%;
    }
  </style>
</head>

<body>

  <div id="racer">
    <canvas id="canvas">
      Sorry, this example cannot be run because your browser does not support the <canvas> element
    </canvas>
    Loading...
  </div>

  <audio id='music'>
    <source src="music/racer.ogg">
    <source src="music/racer.mp3">
  </audio>

  <script src="stats.js"></script>
  <script src="common.js"></script>
  <script>
    var fps            = 60;                      // how many 'update' frames per second
    var step           = 1 / fps;                  // how long is each frame (in seconds)
    var width          = window.innerWidth;       // set canvas to window width
    var height         = window.innerHeight;      // set canvas to window height
    var centrifugal    = 0.3;                      // centrifugal force multiplier when going around curves
    var offRoadDecel   = 0.99;                     // speed multiplier when off road
    var skySpeed       = 0.001;                    // background sky layer scroll speed
    var hillSpeed      = 0.002;                    // background hill layer scroll speed
    var treeSpeed      = 0.003;                    // background tree layer scroll speed
    var skyOffset      = 0;                        // current sky scroll offset
    var hillOffset     = 0;                        // current hill scroll offset
    var treeOffset     = 0;                        // current tree scroll offset
    var segments       = [];                       // array of road segments
    var cars           = [];                       // array of cars on the road
    var stats          = Game.stats('fps');       // mr.doobs FPS counter
    var canvas         = document.getElementById('canvas'); // our canvas...
    var ctx            = canvas.getContext('2d'); // ...and its drawing context
    var background     = null;                     // our background image (loaded below)
    var sprites        = null;                     // our spritesheet (loaded below)
    var resolution     = null;                     // scaling factor to provide resolution independence
    var roadWidth      = 2000;                     // half the roads width
    var segmentLength  = 200;                      // length of a single segment
    var rumbleLength   = 3;                        // number of segments per rumble strip
    var trackLength    = null;                     // z length of entire track (computed)
    var lanes          = 3;                        // number of lanes
    var fieldOfView    = 100;                      // angle (degrees) for field of view
    var cameraHeight   = 1000;                     // z height of camera
    var cameraDepth    = null;                     // z distance camera is from screen (computed)
    var drawDistance   = 300;                      // number of segments to draw
    var playerX        = 0;                        // player x offset from center of road
    var playerZ        = null;                     // player relative z distance from camera (computed)
    var fogDensity     = 5;                        // exponential fog density
    var position       = 0;                        // current camera Z position
    var speed          = 0;                        // current speed
    var maxSpeed       = segmentLength / step;     // top speed
    var accel          = maxSpeed / 5;             // acceleration rate
    var breaking       = -maxSpeed;                // deceleration rate when braking
    var decel          = -maxSpeed / 5;            // 'natural' deceleration rate
    var offRoadLimit   = maxSpeed / 4;             // limit when off road deceleration no longer applies
    var totalCars      = 200;                      // total number of cars on the road
    var currentLapTime = 0;                        // current lap time
    var lastLapTime    = null;                     // last lap time

    var keyLeft        = false;
    var keyRight       = false;
    var keyFaster      = false;
    var keySlower      = false;

    var hud = {
      speed:            { value: null, dom: document.createElement('span')            },
      current_lap_time: { value: null, dom: document.createElement('span')            },
      last_lap_time:    { value: null, dom: document.createElement('span')            },
      fast_lap_time:    { value: null, dom: document.createElement('span')            }
    }

    //=========================================================================
    // UPDATE THE GAME WORLD
    //=========================================================================

    function update(dt) {
      var n, car, carW, sprite, spriteW;
      var playerSegment = findSegment(position + playerZ);
      var playerW       = sprites.PLAYER_STRAIGHT.w * sprites.SCALE;
      var speedPercent  = speed / maxSpeed;
      var dx            = dt * 2 * speedPercent; // at top speed, should be able to cross from left to right (-1 to 1) in 1 second
      var startPosition = position;

      updateCars(dt, playerSegment, playerW);

      position = Util.increase(position, dt * speed, trackLength);

      if (keyLeft) {
        playerX = playerX - dx;
      } else if (keyRight) {
        playerX = playerX + dx;
      }

      playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);

      if (keyFaster) {
        speed = Util.accelerate(speed, accel, dt);
      } else if (keySlower) {
        speed = Util.accelerate(speed, breaking, dt);
      } else {
        speed = Util.accelerate(speed, decel, dt);
      }

      // Off-road handling:
      if ((playerX < -1) || (playerX > 1)) {
        if (speed > offRoadLimit) speed = Util.accelerate(speed, offRoadDecel, dt);

        for (n = 0; n < playerSegment.sprites.length; n++) {
          sprite = playerSegment.sprites[n];
          spriteW = sprite.source.w * sprites.SCALE;
          if (Util.overlap(playerX, playerW, sprite.offset + spriteW / 2 * (sprite.offset > 0 ? 1 : -1), spriteW)) {
            speed = maxSpeed / 5;
            position = Util.increase(playerSegment.p1.world.z, -playerZ, trackLength); // stop in front of sprite
            break;
          }
        }
      }

      // Collision with other cars:
      for (n = 0; n < playerSegment.cars.length; n++) {
        car = playerSegment.cars[n];
        carW = car.sprite.w * sprites.SCALE;
        if (speed > car.speed) {
          if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {
            speed = car.speed * (car.speed / speed);
            position = Util.increase(car.z, -playerZ, trackLength);
            break;
          }
        }
      }

      playerX = Util.limit(playerX, -3, 3);     // limit playerX
      speed = Util.limit(speed, 0, maxSpeed); // limit speed

      skyOffset  = Util.increase(skyOffset,  skySpeed  * playerSegment.curve * (position - startPosition) / segmentLength, 1);
      hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);
      treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * (position - startPosition) / segmentLength, 1);

      // Lap time management:
      if (position > playerZ) {
        if (currentLapTime && (startPosition < playerZ)) {
          lastLapTime    = currentLapTime;
          currentLapTime = 0;
          // Update fastest lap:
          if (lastLapTime <= Util.toFloat(localStorage.fast_lap_time)) {
            localStorage.fast_lap_time = lastLapTime;
            updateHud('fast_lap_time', formatTime(lastLapTime));
          }
          updateHud('last_lap_time', formatTime(lastLapTime));
        } else {
          currentLapTime += dt;
        }
      }

      updateHud('speed', 5 * Math.round(speed / 500));
      updateHud('current_lap_time', formatTime(currentLapTime));
    }

    //-------------------------------------------------------------------------
    
    function updateCars(dt, playerSegment, playerW) {
      var n, car, oldSegment, newSegment;
      for (n = 0; n < cars.length; n++) {
        car = cars[n];
        oldSegment = findSegment(car.z);
        // Update car position:
        car.offset += updateCarOffset(car, oldSegment, playerSegment, playerW);
        car.z = Util.increase(car.z, dt * car.speed, trackLength);
        newSegment = findSegment(car.z);
        if (oldSegment != newSegment) {
          index = oldSegment.cars.indexOf(car);
          oldSegment.cars.splice(index, 1);
          newSegment.cars.push(car);
        }
      }
    }

    function updateCarOffset(car, carSegment, playerSegment, playerW) {
      var i, j, dir, segment, otherCar, otherCarW, lookahead = 20, carW = car.sprite.w * sprites.SCALE;

      // Don't bother steering around other cars when 'out of sight' of the player
      if ((carSegment.index - playerSegment.index) > drawDistance) return 0;

      for (i = 1; i < lookahead; i++) {
        segment = segments[(carSegment.index + i) % segments.length];

        if ((segment === playerSegment) && (car.speed > speed) && (Util.overlap(playerX, playerW, car.offset, carW, 1.2))) {
          if (playerX > 0.5) dir = -1;
          else if (playerX < -0.5) dir = 1;
          else dir = (car.offset > playerX) ? 1 : -1;
          return dir * 1 / i * (car.speed - speed) / maxSpeed;
        }

        for (j = 0; j < segment.cars.length; j++) {
          otherCar = segment.cars[j];
          otherCarW = otherCar.sprite.w * sprites.SCALE;
          if ((car.speed > otherCar.speed) && Util.overlap(car.offset, carW, otherCar.offset, otherCarW, 1.2)) {
            if (otherCar.offset > 0.5) dir = -1;
            else if (otherCar.offset < -0.5) dir = 1;
            else dir = (car.offset > otherCar.offset) ? 1 : -1;
            return dir * 1 / i * (car.speed - otherCar.speed) / maxSpeed;
          }
        }
      }

      // If no cars ahead, steer back on the road if off-road
      if (car.offset < -0.9) return 0.1;
      else if (car.offset > 0.9) return -0.1;
      else return 0;
    }

    //-------------------------------------------------------------------------

    function updateHud(key, value) { // accessing DOM can be slow, so only do it if value has changed
      // Since we don't have a UI, we may ignore this or log values as needed
    }

    function formatTime(dt) {
      var minutes = Math.floor(dt / 60);
      var seconds = Math.floor(dt - (minutes * 60));
      var tenths  = Math.floor(10 * (dt - Math.floor(dt)));
      if (minutes > 0)
        return minutes + "." + (seconds < 10 ? "0" : "") + seconds + "." + tenths;
      else
        return seconds + "." + tenths;
    }

    //=========================================================================
    // RENDER THE GAME WORLD
    //=========================================================================

    function render() {
      var baseSegment   = findSegment(position);
      var basePercent   = Util.percentRemaining(position, segmentLength);
      var playerSegment = findSegment(position + playerZ);
      var playerPercent = Util.percentRemaining(position + playerZ, segmentLength);
      var playerY       = Util.interpolate(playerSegment.p1.world.y, playerSegment.p2.world.y, playerPercent);
      var maxy          = height;

      var x  = 0;
      var dx = - (baseSegment.curve * basePercent);

      ctx.clearRect(0, 0, width, height);

      Render.background(ctx, background, width, height, BACKGROUND.SKY,   skyOffset,  resolution * skySpeed  * playerY);
      Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset, resolution * hillSpeed * playerY);
      Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset, resolution * treeSpeed * playerY);

      var n, i, segment, car, sprite, spriteScale, spriteX, spriteY;

      for (n = 0; n < drawDistance; n++) {
        segment = segments[(baseSegment.index + n) % segments.length];
        segment.looped = segment.index < baseSegment.index;
        segment.fog    = Util.exponentialFog(n / drawDistance, fogDensity);
        segment.clip   = maxy;

        Util.project(segment.p1, (playerX * roadWidth) - x, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
        Util.project(segment.p2, (playerX * roadWidth) - x - dx, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);

        x  = x + dx;
        dx = dx + segment.curve;

        if ((segment.p1.camera.z <= cameraDepth)         || // behind us
            (segment.p2.screen.y >= segment.p1.screen.y) || // back face cull
            (segment.p2.screen.y >= maxy))                  // clip by (already rendered) hill
          continue;

        Render.segment(ctx, width, lanes,
                       segment.p1.screen.x,
                       segment.p1.screen.y,
                       segment.p1.screen.w,
                       segment.p2.screen.x,
                       segment.p2.screen.y,
                       segment.p2.screen.w,
                       segment.fog,
                       segment.color);

        maxy = segment.p1.screen.y;
      }

      for (n = (drawDistance - 1); n > 0; n--) {
        segment = segments[(baseSegment.index + n) % segments.length];

        for (i = 0; i < segment.cars.length; i++) {
          car         = segment.cars[i];
          sprite      = car.sprite;
          spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);
          spriteX     = Util.interpolate(segment.p1.screen.x,     segment.p2.screen.x,     car.percent) + (spriteScale * car.offset * roadWidth * width / 2);
          spriteY     = Util.interpolate(segment.p1.screen.y,     segment.p2.screen.y,     car.percent);
          Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, -0.5, -1, segment.clip);
        }
      }

      if (segment == playerSegment) {
        Render.player(ctx, width, height, resolution, roadWidth, sprites, speed / maxSpeed,
                      cameraDepth / playerZ,
                      width / 2,
                      (height / 2) - (cameraDepth / playerZ * Util.interpolate(playerSegment.p1.camera.y, playerSegment.p2.camera.y, playerPercent) * height / 2),
                      speed * (keyLeft ? -1 : keyRight ? 1 : 0),
                      playerSegment.p2.world.y - playerSegment.p1.world.y);
      }
    }

    function findSegment(z) {
      return segments[Math.floor(z / segmentLength) % segments.length];
    }

    //=========================================================================
    // BUILD ROAD GEOMETRY
    //=========================================================================

    function lastY() { return (segments.length == 0) ? 0 : segments[segments.length - 1].p2.world.y; }

    function addSegment(curve, y) {
      var n = segments.length;
      segments.push({
        index: n,
        p1: { world: { y: lastY(), z: n * segmentLength }, camera: {}, screen: {} },
        p2: { world: { y: y, z: (n + 1) * segmentLength }, camera: {}, screen: {} },
        curve: curve,
        sprites: [],
        cars: [],
        color: Math.floor(n / rumbleLength) % 2 ? COLORS.DARK : COLORS.LIGHT
      });
    }

    function addRoad(enter, hold, leave, curve, y) {
      var startY   = lastY();
      var endY     = startY + (Util.toInt(y, 0) * segmentLength);
      var n, total = enter + hold + leave;
      for (n = 0; n < enter; n++)
        addSegment(Util.easeIn(0, curve, n / enter), Util.easeInOut(startY, endY, n / total));
      for (n = 0; n < hold;  n++)
        addSegment(curve, Util.easeInOut(startY, endY, (enter + n) / total));
      for (n = 0; n < leave; n++)
        addSegment(Util.easeInOut(curve, 0, n / leave), Util.easeInOut(startY, endY, (enter + hold + n) / total));
    }

    var ROAD = {
      LENGTH: { NONE: 0, SHORT:  25, MEDIUM:   50, LONG:  100 },
      HILL:   { NONE: 0, LOW:    20, MEDIUM:   40, HIGH:   60 },
      CURVE:  { NONE: 0, EASY:    2, MEDIUM:    4, HARD:    6 }
    };

    function addStraight(num) {
      num = num || ROAD.LENGTH.MEDIUM;
      addRoad(num, num, num, 0, 0);
    }

    function addHill(num, height) {
      num    = num    || ROAD.LENGTH.MEDIUM;
      height = height || ROAD.HILL.MEDIUM;
      addRoad(num, num, num, 0, height);
    }

    function addCurve(num, curve, height) {
      num    = num    || ROAD.LENGTH.MEDIUM;
      curve  = curve  || ROAD.CURVE.MEDIUM;
      height = height || ROAD.HILL.NONE;
      addRoad(num, num, num, curve, height);
    }
        
    function addLowRollingHills(num, height) {
      num    = num    || ROAD.LENGTH.SHORT;
      height = height || ROAD.HILL.LOW;
      addRoad(num, num, num,  0, height / 2);
      addRoad(num, num, num,  0, -height);
      addRoad(num, num, num,  ROAD.CURVE.EASY, height);
      addRoad(num, num, num,  0, 0);
      addRoad(num, num, num, -ROAD.CURVE.EASY, height / 2);
      addRoad(num, num, num,  0, 0);
    }

    function addSCurves() {
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY,    ROAD.HILL.NONE);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  ROAD.CURVE.MEDIUM,  ROAD.HILL.MEDIUM);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  ROAD.CURVE.EASY,   -ROAD.HILL.LOW);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY,    ROAD.HILL.MEDIUM);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.MEDIUM, -ROAD.HILL.MEDIUM);
    }

    function addBumps() {
      addRoad(10, 10, 10, 0,  5);
      addRoad(10, 10, 10, 0, -2);
      addRoad(10, 10, 10, 0, -5);
      addRoad(10, 10, 10, 0,  8);
      addRoad(10, 10, 10, 0,  5);
      addRoad(10, 10, 10, 0, -7);
      addRoad(10, 10, 10, 0,  5);
      addRoad(10, 10, 10, 0, -2);
    }

    function addDownhillToEnd(num) {
      num = num || 200;
      addRoad(num, num, num, -ROAD.CURVE.EASY, -lastY() / segmentLength);
    }

    function resetRoad() {
      segments = [];

      addStraight(ROAD.LENGTH.SHORT);
      addLowRollingHills();
      addSCurves();
      addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);
      addBumps();
      addLowRollingHills();
      addCurve(ROAD.LENGTH.LONG * 2, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
      addStraight();
      addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH);
      addSCurves();
      addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.MEDIUM, ROAD.HILL.NONE);
      addHill(ROAD.LENGTH.LONG, ROAD.HILL.HIGH);
      addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);
      addBumps();
      addHill(ROAD.LENGTH.LONG, -ROAD.HILL.MEDIUM);
      addStraight();
      addSCurves();
      addDownhillToEnd();

      segments[findSegment(playerZ).index + 2].color = COLORS.START;
      segments[findSegment(playerZ).index + 3].color = COLORS.START;
      for (var n = 0; n < rumbleLength; n++)
        segments[segments.length - 1 - n].color = COLORS.FINISH;

      trackLength = segments.length * segmentLength;
    }

    function resetCars() {
      cars = [];
      var n, car, segment, offset, z, sprite, speed;
      for (var n = 0; n < totalCars; n++) {
        offset = Math.random() * Util.randomChoice([-0.8, 0.8]);
        z      = Math.floor(Math.random() * segments.length) * segmentLength;
        sprite = Util.randomChoice(sprites.CARS);
        speed  = maxSpeed / 4 + Math.random() * maxSpeed / (sprite == sprites.SEMI ? 4 : 2);
        car = { offset: offset, z: z, sprite: sprite, speed: speed };
        segment = findSegment(car.z);
        segment.cars.push(car);
        cars.push(car);
      }
    }

    //=========================================================================
    // THE GAME LOOP
    //=========================================================================

    Game.run({
      canvas: canvas, render: render, update: update, stats: stats, step: step,
      images: ["background", "sprites"],
      keys: [
        { keys: [KEY.LEFT,  KEY.A], mode: 'down', action: function() { keyLeft   = true;  } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function() { keyRight  = true;  } },
        { keys: [KEY.UP,    KEY.W], mode: 'down', action: function() { keyFaster = true;  } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'down', action: function() { keySlower = true;  } },
        { keys: [KEY.LEFT,  KEY.A], mode: 'up',   action: function() { keyLeft   = false; } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'up',   action: function() { keyRight  = false; } },
        { keys: [KEY.UP,    KEY.W], mode: 'up',   action: function() { keyFaster = false; } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'up',   action: function() { keySlower = false; } }
      ],
      ready: function(images) {
        background = images[0];
        sprites    = images[1];
        reset(); // Ensure the game initializes properly
      }
    });

    function reset(options) {
      options       = options || {};
      canvas.width  = width  = window.innerWidth;
      canvas.height = height = window.innerHeight;
      lanes                  = Util.toInt(options.lanes, lanes);
      roadWidth              = Util.toInt(options.roadWidth, roadWidth);
      cameraHeight           = Util.toInt(options.cameraHeight, cameraHeight);
      drawDistance           = Util.toInt(options.drawDistance, drawDistance);
      fogDensity             = Util.toInt(options.fogDensity, fogDensity);
      fieldOfView            = Util.toInt(options.fieldOfView, fieldOfView);
      segmentLength          = Util.toInt(options.segmentLength, segmentLength);
      rumbleLength           = Util.toInt(options.rumbleLength, rumbleLength);
      cameraDepth            = 1 / Math.tan((fieldOfView / 2) * Math.PI / 180);
      playerZ                = (cameraHeight * cameraDepth);
      resolution             = height / 480;

      if ((segments.length == 0) || (options.segmentLength) || (options.rumbleLength))
        resetRoad(); // only rebuild road when necessary
    }

    // Handle window resizing
    window.addEventListener('resize', function() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      reset(); // Call reset to adjust game settings if necessary
    });

  </script>

</body>
</html>
